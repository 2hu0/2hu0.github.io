<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>面向对象设计的六大原则</title>
      <link href="/2022/03/28/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99/"/>
      <url>/2022/03/28/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99/</url>
      
        <content type="html"><![CDATA[<h1 id="面向对象设计的六大原则"><a href="#面向对象设计的六大原则" class="headerlink" title="面向对象设计的六大原则"></a>面向对象设计的六大原则</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>学习面向对象应该遵循的六大原则,能更好的帮助我们去理解面向对象的概念，在平时写代码时候用到，来养成我们良好的代码规范。</p><h2 id="六大原则"><a href="#六大原则" class="headerlink" title="六大原则"></a>六大原则</h2><ul><li>SRP (<code>Single Responsibility Principle</code>)   <strong>单一职责原则</strong></li><li>OCP(<code>Open Closed Principle</code>) <strong>开闭原则</strong> </li><li>LSP(<code>Liskov Substitution Principle</code>)  <strong>里氏替换原则</strong></li><li>DIP(<code>Dependency Inversion Principle</code>) <strong>依赖倒置原则</strong></li><li>LOD(<code>Law of Demeter</code>) <strong>迪米特法则</strong></li><li>ISP (<code>Interface Segregation Principle</code>) <strong>接口隔离原则</strong></li></ul><h3 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h3><blockquote><p><code>Definition</code> : There should never be more than one reason for a class to change.</p></blockquote><p>其解释就是有且仅有一个类来引起类的改变,说的就是一个类只担负一个职责。</p><p>单一职责规定每个类都应该有单一的功能,该功能由这个类完全封装。所有这个类的服务都应该和该功能平行。</p><p>如果一个类所承担的职责过多,就等于把这些职责全都耦合在了一起,一个职责的变化极大可能会影响到别的职责的实现过程,很容易使我们的设计破坏。</p><p>因此我们应该尽可能的遵守单一原则。</p><p>举个形象点的例子，在公司里可能会有这样的角色。由于某些不可抗力，一个开发人员可能需要去承担多个原则,既要自己去设计方案写需求，还要自己去编写代码实现需求，而且还要去客户交流去解决大大小小的问题。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Code2hu0</span><span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">writePlan</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">writeCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">meetCustomer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​       这种代码的写法显然不符合我们上文所提到的单一原则,因为有多种类都可以去改变类的改变。当哪天需要多加一个功能什么的,其他使用该类的类也要进行相应的变化，这样我们在后期维护代码时候成本就非常高。</p><p>​        因此我们需要把这些方法都拆分为独立的职责,让每一个类只负责一个方法。每个类只用专心处理自己的方法即可。</p><h4 id="单一职责的好处与解决的问题"><a href="#单一职责的好处与解决的问题" class="headerlink" title="单一职责的好处与解决的问题"></a>单一职责的好处与解决的问题</h4><ul><li>降低耦合,提高内聚力。类的复杂性降低, 每个类有清晰的实现功能。</li><li>代码的逻辑性提高,可读性提高,减少了后期代码的维护成本。</li><li>降低了因某个类变更而引起的风险。增强程序的健壮性。</li></ul><h4 id="单一职责的注意事项"><a href="#单一职责的注意事项" class="headerlink" title="单一职责的注意事项"></a>单一职责的注意事项</h4><ul><li>单一职责的关键就是如何细化<strong>职责</strong></li><li>单一职责原则提出标准：用职责和变化原因来衡量接口或者类设计的是否优良，但是职责的变换原因在不同的项目之间都是不可度量的，所以我们需要<strong>因地制宜</strong>。</li><li>接口一定要做到单一职责,类的设计尽量做到只有一个原因来使它引起变化。</li></ul><h3 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h3><blockquote><p><code>Definition</code> ：software entities (classes,modules,function,etc.）should be open for extension, but closed for modification.</p></blockquote><p>中文解释就是:一个软件实体，如类、模块、函数应该对扩展开放，对修改关闭。</p><p>开闭原则是<code>Java</code>世界里最基础的设计原则，是面向对象设计中’‘可复用设计“的基石，其他很多的设计原则和设计模式都是实现开闭原则的一种手段。</p><p>因此，软件中的各种组件 如<code>Module</code> 、<code>class</code>、<code>Function</code> 需要进行改变时候，我们应该在不修改已有代码的基础上来引进新的功能。做到能不动就不动。开闭原则中的<strong>开</strong>，指的是对于组件功能的扩展是开放的；开闭原则中的<strong>闭</strong>，指的是对于现有代码的修改是封闭的。</p><p>我们遵循开闭原则的最好手段就是<strong>抽象</strong>。把系统所有可能的行为抽象成一个抽象底层。这也就是我们为什么<strong>要面向接口编程</strong>的原因，例如上文提到的工程师类，我们说的是把方法抽离成单独的类，但更好的方式是把每个职责封装到接口里。</p><p>作为方法设计的抽象层，我们要预见所有可能的扩展，来使得后面进行扩展时，我们的抽象底层不用动。只需要通过从抽象底层所具体出的一个个实例来进行对程序的扩展。</p><p>推荐文章:<a href="https://mp.weixin.qq.com/s/Dg9LcKJBrabcnvC_6wga-A">我们为什么要面向接口编程？</a></p><h4 id="开闭原则的好处"><a href="#开闭原则的好处" class="headerlink" title="开闭原则的好处"></a>开闭原则的好处</h4><ul><li>可复用好</li><li>可维护性好</li></ul><h3 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h3><blockquote><p><code>Definition</code>: Function that use pointers of references to base classes must be able to use objects of derived classes without knowing it.</p></blockquote><p>中文解释就是：所有引用基类的地方必须能透明地使用其子类的对象。</p><p>通俗点说：只要父类能出现的地方子类就可以出现,而且替换为子类也不会产生异常，但是反过来是不可以的。</p><p><strong>一句话：子类可以扩展父类没有的功能，但是子类不能改变父类原有的功能。</strong></p><p>面向对象的三大特性<strong>继承</strong>、<strong>封装</strong>、<strong>多态</strong>并不和谐。 我们知道，<strong>继承</strong>有很多缺点，当子类继承父类时，虽然可以复用父类的代码，但是父类的属性和方法都是对子类是透明的，子类可以随意修改父类的成员。如果需求变更，子类对父类的方法进行一些复写的时候，其他的子类可能就需要一起随之改变，这一定程度上违反了我们<strong>封装</strong>的原则，解决的方案就是引入里氏替换原则。</p><p>它包含了以下4曾含义:</p><ul><li>子类必须完全实现父类的方法。在类中调用其他类是务必要使用父类或接口，如果不能使用父类或接口，则说明类的设计已经违背了<code>LSP</code>原则。</li><li>子类可以有自己的个性。子类当然可以有自己的行为和外观了，也就是方法和属性。</li><li>覆盖或实现父类的方法时输入参数可以被放大。即子类可以覆盖父类的方法，但输入参数应比父类方法中的大，这样在子类代替父类的时候，调用的仍然是父类的方法。即以子类中方法的前置条件必须与超类中被覆盖的方法的前置条件相同或者更宽松。</li><li>覆盖或实现父类的方法时输出结果可以被缩小，也就是说返回值要小于或者等于父类的方法返回值。</li></ul><p>比如父类有一个方法,参数是<strong>HashMap</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Father</span><span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token class-name">HashMap</span> map<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">System<span class="token punctuation">.</span>Out</span><span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"父类被执行"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>子类的同名方法输入参数的类型可以扩大,这里我们输入参数为<strong>Map</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Son</span> <span class="token keyword">extends</span> <span class="token class-name">Father</span><span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token class-name">Map</span> map<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">System<span class="token punctuation">.</span>Out</span><span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"子类被执行"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>测试父类方法的执行结果</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">Father</span> father <span class="token operator">=</span>  <span class="token keyword">new</span> <span class="token class-name">Father</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">HashMap</span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        father<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果 :父类被执行</p><p>根据里氏替换原则,只要父类能出现的地方子类就可以出现,而且替换为子类也不会产生任何的异常。我们调用子类的方法。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Son</span> son <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Son</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">HashMap</span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        father<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果 :父类被执行</p><p>可以看到两次的运行结果是一样的，因为子类方法的输入参数类型范围扩大了，子类代替父类传递到调用者中，子类的方法永远不会执行。如果想让子类的方法执行，可以重写方法体。</p><p>反之，如果子类的输入参数类型范围比父类还小，比如父类中的参数是Map，而子类是HashMap，那么上述代码的结果就会是子类的方法，这难道不对吗？子类显示自己的内容啊。其实是不对的，因为子类没有复写父类的同名方法，方法就被执行了，这会引起逻辑的混乱，如果父类是抽象类，子类是实现类，你传递一个这样的实现类就违背了父类的意图了，所以子类覆盖或重载父类的方法时输入参数必定是相同或者放大的。</p><h4 id="里氏替换原则的优点"><a href="#里氏替换原则的优点" class="headerlink" title="里氏替换原则的优点"></a>里氏替换原则的优点</h4><ul><li>提高代码的重用性，子类拥有父类的方法和属性；</li><li>提高代码的可扩展性，子类可形似于父类，但异于父类，保留自我的特性；</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>继承是侵入性的，只要继承就必须拥有父类的所有方法和属性，在一定程度上约束了子类，降低了代码的灵活性；</li><li>增加了耦合，当父类的常量、变量或者方法被修改了，需要考虑子类的修改，所以一旦父类有了变动，很可能会造成非常糟糕的结果，要重构大量的代码。</li></ul><h3 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h3><blockquote><p><code>Definition</code>:High-level modules should not depend on low-level modules. Both should depend on abstractions.</p><p>中文:<strong>高层模块不应该依赖低层模块，两者都应该依赖其抽象</strong></p></blockquote><blockquote><p><code>Definition</code>:Abstractions should not depend on details. Details should depend on abstractions.</p><p>中文:<strong>抽象不应该依赖细节；细节应该依赖抽象</strong></p></blockquote><p>该原则提到了两个模块，高层和底层模块。什么意思呢？</p><p>不可分割的原子逻辑就是底层模块，原子逻辑的再组装就是高层模块。</p><p>抽象在Java中就是接口和抽象类,不能被实例化。而细节是实现接口或继承抽象类产生的类，也就是可以被实例化的实现类。依赖倒置原则是指模块间的依赖是通过抽象来发生的，实现类之间不发生直接的依赖关系，其依赖关系是通过接口是来实现的，这就是俗称的面向接口编程。</p><p>我们用人做健身运动来举例,当一个人跑步的时候，其代码表示为：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RunSport</span><span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token string">"Running!"</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">People</span><span class="token punctuation">&#123;</span>    <span class="token comment">//运动的方法</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSport</span><span class="token punctuation">(</span><span class="token class-name">Sport</span> sport<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"人"</span><span class="token operator">+</span>sport<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">People</span> people <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">People</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">RunSport</span> sport <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RunSport</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        people<span class="token punctuation">.</span><span class="token function">doSport</span><span class="token punctuation">(</span>sport<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行结果:人Running!</p><p>现在我们的人不想跑步了，他想去游泳，在这个类中，我们发现是很难做的，因为我们的<strong>People</strong>类依赖与一个具体的实现类<strong>RunSport</strong>，如果我们以后要增加很多的运动，那<strong>People</strong>类不是一直都要被修改？这显然不是我们想要看到的结果。</p><p>所以我们需要用面向接口编程的思想来优化我们的方案</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Sport</span><span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> string <span class="token function">type</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RunSport</span> <span class="token keyword">implements</span> <span class="token class-name">Sport</span><span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">type</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token string">"Running！"</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SwimmingSport</span> <span class="token keyword">implements</span> <span class="token class-name">Sport</span><span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">type</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token string">"Swimming！"</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">People</span><span class="token punctuation">&#123;</span>    <span class="token comment">//运动的方法</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSport</span><span class="token punctuation">(</span><span class="token class-name">Sport</span> sport<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"人"</span><span class="token operator">+</span>sport<span class="token punctuation">.</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们把运动单独抽象为一个接口,每个项目都继承该接口并且重写方法，这样一来，人的代码就不必改动。</p><p><strong>相对于细节的多变性，抽象的东西要稳定的多</strong>依赖倒置原则就是基于这样一句话来进行设计的。</p><h3 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h3><blockquote><p><code>Definition</code>:talk only to your immediate friends.(只与直接的朋友通信)</p></blockquote><p>一个类应该对自己需要耦合或者调用的类尽可能的知道的少,类和类之间的关系越密切，耦合度越大。那么累的变化对其耦合的类也会产生很大的影响。不利于我们遵守 <strong>低耦合，高内聚</strong> 的设计原则</p><p>什么是直接的朋友呢？每个对象都必然与其他对象有耦合关系，两个对象的耦合就成为朋友关系，这种关系的类型很多，例如组合、聚合、依赖等。其中，我们称出现成员变量、方法参数、方法返回值中的类为直接的朋友，而出现在局部变量中的类则不是直接的朋友。也就是说，陌生的类最好不要作为局部变量的形式出现在类的内部。</p><p>举一个之前看到过的例子，上体育课之前，老师让班长先去体务室拿10个足球，等下上课的时候要用。根据这一场景，我们可以设计出三个类 <strong>Teacher</strong>(老师)，<strong>Monitor</strong> (班长) 和 <strong>FootBall</strong> (足球)，以及发布命令的方法<code>command</code> 和 拿篮球的方法<code>takeBall</code>，</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Teacher</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 命令班长去拿球</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">command</span><span class="token punctuation">(</span><span class="token class-name">Monitor</span> monitor<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">FootBalll</span><span class="token punctuation">></span></span> ballList <span class="token operator">=</span>            <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">FootBall</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 初始化足球数目</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            ballList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FootBall</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 通知班长开始去拿球</span>        monitor<span class="token punctuation">.</span><span class="token function">takeBall</span><span class="token punctuation">(</span>ballList<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FootBall</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Monitor</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 拿球</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">takeBall</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">FootBall</span><span class="token punctuation">></span></span> balls<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"足球数目："</span> <span class="token operator">+</span> balls<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后，我们写一个情景类进行测试：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Teacher</span> teacher <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Teacher</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        teacher<span class="token punctuation">.</span><span class="token function">command</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Monitor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果为 10</p><p>虽然结果是正确的，但我们的程序其实还是存在问题，因为从场景来说，老师只需命令班长拿足球即可，Teacher只需要一个朋友—-Monitor，但在程序里，Teacher的方法体中却依赖了FootBall类，也就是说，Teacher类与一个陌生的类有了交流，这样Teacher的健壮性就被破坏了，因为一旦FootBall类做了修改，那么Teacher也需要做修改，这很明显违背了迪米特法则。</p><p>因此，我们需要对程序做些修改，在Teacher的方法中去掉对FootBall类的依赖，只让Teacher类与朋友类Monitor产生依赖，修改后的代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Teacher</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 命令班长去拿球</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">command</span><span class="token punctuation">(</span><span class="token class-name">Monitor</span> monitor<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 通知班长开始去拿球</span>        monitor<span class="token punctuation">.</span><span class="token function">takeBall</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Monitor</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 拿球</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">takeBall</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">FootBall</span><span class="token punctuation">></span></span> ballList <span class="token operator">=</span>             <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">FootBall</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 初始化足球数目</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            ballList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FootBall</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"足球数目："</span> <span class="token operator">+</span> ballList<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样一来，Teacher类就不会与FootBall类产生依赖了，即时日后因为业务需要修改FootBall也不会影响Teacher类。</p><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>迪米特法则不希望类之间建立直接的联系。如果真的有需要建立联系，也希望能通过它的“朋友”类来转达。因此，应用迪米特法则有可能造成的一个后果就是：系统中存在大量的中介类，这些类之所以存在完全是为了传递类之间的相互调用关系——这在一定程度上增加了系统的复杂度,同时也为系统的维护带来了难度。所以，在采用迪米特法则时需要反复权衡，不遵循不对，严格执行又会“过犹不及”。既要做到让结构清晰，又要做到高内聚低耦合。</p><p>还是那四个字： <strong>因地制宜</strong> </p><h3 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h3><p>所谓<code>ISP</code>原则，即：<code>Interface Segregation Principle</code>，<strong>接口隔离原则</strong>。原始定义如下：</p><blockquote><p>Clients should not be forced to depend upon interfaces that they do not use.(客户端只依赖于它所需要的接口；它需要什么接口就提供什么接口，把不需要的接口剔除掉。)</p></blockquote><blockquote><p>The dependency of one class to another one should depend on the smallest possible interface.(类间的依赖关系应建立在最小的接口上。)</p></blockquote><p>即，<strong>接口尽量细化，接口中的方法尽量少</strong>。接口隔离原则与单一职责原则的审视角度是不同的，单一职责原则要求的是类和接口职责单一，注重的是职责，这是业务逻辑上的划分，而接口隔离原则要求接口的方法尽量少。根据接口隔离原则拆分接口时，首先必须满足单一职责原则。</p><p>单一职责原则要求的是类和接口职责单一，注重的是职责，一个职责的接口是可以有多个方法的，而接口隔离原则要求的是接口的方法尽量少，模块尽量单一，如果需要提供给客户端很多的模块，那么就要相应的定义多个接口，不要把所有的模块功能都定义在一个接口中，那样会显得很臃肿。</p><p>举个例子，在我们年轻人的观念里，好的智能手机应该是价格便宜，外观好看，功能丰富的，由此我们可以定义一个智能手机的抽象接口 <strong>ISmartPhone</strong>，代码如下所示：</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ISmartPhone</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">cheapPrice</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">goodLooking</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">richFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接着，我们定义一个手机接口的实现类，实现这三个抽象方法，</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SmartPhone</span> <span class="token return-type class-name">implements</span> ISmartPhone<span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">cheapPrice</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        System<span class="token punctuation">.</span><span class="token keyword">out</span><span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"便宜"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">goodLooking</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        System<span class="token punctuation">.</span><span class="token keyword">out</span><span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"好看"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">richFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        System<span class="token punctuation">.</span><span class="token keyword">out</span><span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"功能多"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后，定义一个用户的实体类 <strong>User</strong>，并定义一个构造方法，以<strong>ISmartPhone</strong> 作为参数传入，同时，我们也定义一个使用的方法<strong>usePhone</strong> 来调用接口的方法，</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">ISmartPhone</span> phone<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">User</span><span class="token punctuation">(</span><span class="token class-name">ISmartPhone</span> phone<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>phone <span class="token operator">=</span> phone<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">usePhone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        phone<span class="token punctuation">.</span><span class="token function">cheapPrice</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        phone<span class="token punctuation">.</span><span class="token function">goodLooking</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        phone<span class="token punctuation">.</span><span class="token function">richFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看出，当我们实例化<code>User</code>类并调用其方法<code>usePhone</code>后，控制台上就会显示手机接口三个方法的方法体信息，这种设计看上去没什么大毛病，但是我们可以仔细想下，<strong>ISmartPhone</strong>这个接口的设计是否已经达到最优了呢？很遗憾，答案是没有，接口其实还可以再优化。</p><p>因为除了年轻人之外，中年商务人士也在用智能手机，在他们的观念里，智能手机并不需要丰富的功能，甚至不用考虑是否便宜 (有钱就是任性~~~~)，因为成功人士都比较忙，对智能手机的要求大多是外观大气，功能简单即可，这才是他们心中好的智能手机的特征，这样一来，我们定义的 <strong>ISmartPhone</strong> 接口就无法适用了，因为我们的接口定义了智能手机必须满足三个特性，如果实现该接口就必须三个方法都实现，而对商务人员的标准来说，我们定义的方法只有外观符合且可以重用而已。你可能会说，我可以重写一个实现类啊，只实现外观的方法，另外两个方法置空，什么都不写，这不就行了吗？但是这也不行，因为 <strong>User</strong> 引用的是<strong>ISmartPhone</strong> 接口，它调用三个方法，你只实现了两个，那么打印信息就少了两条了，只靠外观的特性，使用者怎么知道智能手机是否符合自己的预期？</p><p>分析到这里，我们大概就明白了，其实<strong>ISmartPhone</strong>的设计是有缺陷的，过于臃肿了，按照接口隔离原则，我们可以根据不同的特性把智能手机的接口进行拆分，这样一来，每个接口的功能就会变得单一，保证了接口的纯洁性，也进一步提高了代码的灵活性和稳定性。</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="组合复用法则"><a href="#组合复用法则" class="headerlink" title="组合复用法则"></a>组合复用法则</h3><p>CRP(Composite Reuse Principle) </p><p>组合复用原则的核心思想是：<strong>尽量使用对象组合，而不是继承来达到复用的目的</strong>。该原则就是在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分：新的对象通过向这些对象的委派达到复用已有功能的目的。</p><p>继承的缺点主要有以下几点：</p><ul><li>继承复用破坏数据封装性，将基类的实现细节全部暴露给了派生类，基类的内部细节常常对派生类是透明的，白箱复用。虽然简单，但不安全，不能在程序的运行过程中随便改变。</li><li>基类的实现发生了改变，派生类的实现也不得不改变。</li><li>从基类继承而来的派生类是静态的，不可能在运行时间内发生改变，因此没有足够的灵活性。</li></ul><p>由于组合可以将已有的对象纳入到新对象中，使之成为新对象的一部分，因此新对象可以调用已有对象的功能，这样做有下面的好处：</p><ul><li>新对象存取<code>组成对象</code>的唯一方法是通过<code>组成对象</code>的<code>getter/setter</code>方法。</li><li>组合复用是黑箱复用，因为组成对象的内部细节是新对象所看不见的。</li><li>组合复用所需要的依赖较少。</li><li>每一个新的类可以将焦点集中到一个任务上。</li><li>组合复用可以在运行时间动态进行，新对象可以动态的引用与成分对象类型相同的对象。</li></ul><p>组合复用的缺点：就是用组合复用建造的系统会有较多的对象需要管理。</p><p>组合复用原则可以使系统更加灵活，类与类之间的耦合度降低，一个类的变化对其他类造成的影响相对较少，因此一般首选使用组合来实现复用；其次才考虑继承。在使用继承时，需要严格遵循里氏代换原则，有效使用继承会有助于对问题的理解，降低复杂度，而滥用继承反而会增加系统构建和维护的难度以及系统的复杂度，因此需要慎重使用继承复用。</p><p>使用继承时必须满足<code>Is-A</code>的关系是才能使用继承，而组合却是一种<code>Has-A</code>的关系。导致错误的使用继承而不是使用组合的一个重要原因可能就是错误的把<code>Has-A</code>当成了<code>Is-A</code></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>六大原则虽说是原则，但它们并不是强制性的，更多的是建议。</p><p>我们首先得学会走路，再学跑步。</p><p>学习这些经典的设计原则，让我们脑中有<strong>货</strong>，这样才能<strong>因地制宜</strong>，选用合适的设计方案进行开发。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL基础笔记</title>
      <link href="/2022/03/20/MySQL%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/03/20/MySQL%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="语法分类"><a href="#语法分类" class="headerlink" title="语法分类"></a>语法分类</h2><ul><li>DDL：数据库定义语言，用来定义数据库对象(数据库、表、字段)</li><li>DML:  数据操作语言，用来对数据库中的数据进行增删改</li><li>DQL：数据查询语言，用来查询数据库中表的记录</li><li>DCL：数据控制语言，用来创建数据库用户、控制数据库的控制权限</li></ul><h3 id="DDL（数据定义语言）"><a href="#DDL（数据定义语言）" class="headerlink" title="DDL（数据定义语言）"></a>DDL（数据定义语言）</h3><p>数据定义语言</p><h4 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h4><p>查询所有数据库：</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SHOW DATABASES;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查询当前数据库：</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SELECT DATABASE();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>创建数据库：</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">CREATE DATABASES[IF NOT EXISTS]数据库名[DEFAULT CHARSET 字符集][COLLATE 排序规则];<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>删除数据库：</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">DROP DATABASE[IF EXISTS] 数据库名;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用数据库:</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">USE 数据库名;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h5><ul><li>UTF8字符集长度为3字节，有些符号占4字节，所以推荐用utf8mb4字符集</li></ul><h4 id="表操作"><a href="#表操作" class="headerlink" title="表操作"></a>表操作</h4><p>查询当前数据库所有的表:</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SHOW TABLES;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查询表结构:</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">DESC 表名;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查询指定表的建表语句：</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SHOW CREATE TABLE 表名;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>创建表:</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">CREATE TABLE 表名(    字段1 字段1类型 [COMMENT 字段1注释],    字段2 字段2类型 [COMMENT 字段2注释],    字段3 字段3类型 [COMMENT 字段3注释],    ...    字段n 字段n类型 [COMMENT 字段n注释])[ COMMENT 表注释 ];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意最后一个字段后面是没有逗号的</p><p>添加字段:</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">ALTER TABLE 表名 ADD 字段名 类型(长度) [COMMENT 注释] [约束];-- 例子ALTER TABLE emp ADD nickname varchar(20) COMMENT &#39;昵称&#39;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>修改数据类型:</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">ALTER TABLE 表名 MODIFY 字段名 新数据类型(长度);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>修改字段名和字段类型:</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">ALTER TABLE 表名 CHANGE 旧字段名 新字段名 类型(长度)[COMMENT 注释][约束]; -- 例子：将emp表的nickname字段修改为username,类型为varchar(30)ALTER TABLE emp CHANGE nickname username varchar(30) COMMENT &#39;昵称&#39;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>删除字段:</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">ALTER TABLE 表名 DROP 字段名;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>修改表名:</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">ALTER TABLE 表名 RENAME TO 新表名<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>删除表:</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">DROP TABLE [IF EXISTS] 表名;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>删除表，并且重新创建该表:</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">TRUNCATE TABLE 表名;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="DML-数据库操作语言"><a href="#DML-数据库操作语言" class="headerlink" title="DML(数据库操作语言)"></a>DML(数据库操作语言)</h3><h4 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h4><p>指定字段:</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">INSERT INTO 表名(字段1,字段2,....) VALUES(值1,值2,...);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>全部字段:</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">INSERT INTO 表名 VALUES (值1,值2,....);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>批量添加数据:</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">INSERT INTO 表名 (字段名1, 字段名2, ...) VALUES (值1, 值2, ...), (值1, 值2, ...), (值1, 值2, ...);INSERT INTO 表名 VALUES (值1, 值2, ...), (值1, 值2, ...), (值1, 值2, ...);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h5 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h5><ul><li>字符串和日期类型应该包含在引号中</li><li>插入的数据大小应该在字段的指定范围内</li></ul><h4 id="更新和删除数据"><a href="#更新和删除数据" class="headerlink" title="更新和删除数据"></a>更新和删除数据</h4><p>修改数据:</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">UPDATE 表名 SET 字段名1 &#x3D; 值1,字段名2 &#x3D; 值2,...[WHERE 条件];-- 例子UPDATE emp SET name &#x3D; &#39;Jack&#39; WHERE id &#x3D; 1;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>删除数据:</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">DELETE FROM 表名[WHERE 条件];<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="DQL-数据查询语言"><a href="#DQL-数据查询语言" class="headerlink" title="DQL(数据查询语言)"></a>DQL(数据查询语言)</h3><p>语法:</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SELECT    字段列表FROM    表名字段WHERE    条件列表GROUP BY    分组字段列表HAVING    分组后的条件列表ORDER BY    排序字段列表LIMIT    分页参数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="基础查询"><a href="#基础查询" class="headerlink" title="基础查询"></a>基础查询</h4><p>查询多个字段:</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SELECT 字段1, 字段2, 字段3, ... FROM 表名;SELECT * FROM 表名;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>设置别名:</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SELECT 字段1 [ AS 别名1 ], 字段2 [ AS 别名2 ], 字段3 [ AS 别名3 ], ... FROM 表名;SELECT 字段1 [ 别名1 ], 字段2 [ 别名2 ], 字段3 [ 别名3 ], ... FROM 表名;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>去重:</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SELECT DISTINCT 字段列表 FROM 表名;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>转义:</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SELECT * FROM 表名 WHERE name LIKE &#39;&#x2F;_张三&#39; ESCAPE &#39;&#x2F;&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h4><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SELECT 字段列表 FROM 表名 WHERE 条件列表;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>条件：</p><table><thead><tr><th align="center">比较运算符</th><th align="left">功能</th></tr></thead><tbody><tr><td align="center">&lt;&gt; 或！=</td><td align="left">不等于</td></tr><tr><td align="center">BETWEEN…AND…</td><td align="left">在某个范围内(含最小和最大)</td></tr><tr><td align="center">IN(…)</td><td align="left">在in之后的列表中的值,多选一</td></tr><tr><td align="center">LIKE 占位符</td><td align="left">模糊匹配(_匹配单个字符，%匹配任意个字符)</td></tr><tr><td align="center">IS NULL</td><td align="left">是NULL</td></tr></tbody></table><table><thead><tr><th>逻辑运算符</th><th>功能</th></tr></thead><tbody><tr><td>AND或&amp;&amp;</td><td>并且(多个条件同时成立)</td></tr><tr><td>OR或者||</td><td>或者(多个条件任意一个成立)</td></tr><tr><td>NOT或！</td><td>非，不是</td></tr></tbody></table><p>例子:</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">-- 没有身份证select * from employee where idcard is null or idcard &#x3D; &#39;&#39;;-- 有身份证select * from employee where idcard;select * from employee where idcard is not null;-- 年龄在20到30之间select * from employee where age between 20 and 30;select * from employee where age &gt;&#x3D; 20 and age &lt;&#x3D; 30;-- 下面语句不报错，但查不到任何信息select * from employee where age between 30 and 20;-- 性别为女且年龄小于30select * from employee where age &lt; 30 and gender &#x3D; &#39;女&#39;;-- 年龄等于25或30或35select * from employee where age &#x3D; 25 or age &#x3D; 30 or age &#x3D; 35;select * from employee where age in (25, 30, 35);-- 姓名为两个字select * from employee where name like &#39;__&#39;;-- 身份证最后为Xselect * from employee where idcard like &#39;%X&#39;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="聚合查询"><a href="#聚合查询" class="headerlink" title="聚合查询"></a>聚合查询</h4><p>一些常见的聚合函数:</p><table><thead><tr><th>函数</th><th align="left">功能</th></tr></thead><tbody><tr><td>count</td><td align="left">统计数量</td></tr><tr><td>max</td><td align="left">最大值</td></tr><tr><td>min</td><td align="left">最小值</td></tr><tr><td>avg</td><td align="left">平均值</td></tr><tr><td>sum</td><td align="left">求和</td></tr></tbody></table><p>语法:</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SELECT 聚合函数(字段列表) FROM 表名;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>例子:</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SELECT count(id) FROM employee WHERE workaddress &#x3D; &quot;广东省&quot;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h4><p>语法:</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SELECT 字段列表 FROM 表名 [WHERE 条件] GROUP BY 分组字段名[HAVING 分组后的过滤条件];<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>where和having的区别:</p><ul><li>执行时机不同:where是<strong>分组之前</strong>进行过滤,不满足where条件不参与分组；having是<strong>分组之后</strong>对结果进行过滤。</li><li>判断条件不同:where不能对聚合函数进行判断,而having可以</li></ul><p>例子:</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">-- 根据性别分组，统计男性和女性数量（只显示分组数量，不显示哪个是男哪个是女）select count(*) from employee group by gender;-- 根据性别分组，统计男性和女性数量select gender, count(*) from employee group by gender;-- 根据性别分组，统计男性和女性的平均年龄select gender, avg(age) from employee group by gender;-- 年龄小于45，并根据工作地址分组select workaddress, count(*) from employee where age &lt; 45 group by workaddress;-- 年龄小于45，并根据工作地址分组，获取员工数量大于等于3的工作地址select workaddress, count(*) address_count from employee where age &lt; 45 group by workaddress having address_count &gt;&#x3D; 3;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项:"></a>注意事项:</h5><ul><li>执行顺序:where &gt;聚合函数&gt;having</li><li>分组之后,查询的字段一般为聚合函数和分段函数,查询其他字段无任何意义</li></ul><h4 id="排序查询"><a href="#排序查询" class="headerlink" title="排序查询"></a>排序查询</h4><p>语法:</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SELECT 字段列表 FROM 表名 ORDER BY 字段1 排序方式1,字段2 排序方式2;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>排序方式:</p><ul><li>ASC：升序(默认)</li><li>DESC：降序</li></ul><p>例子：</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">-- 根据年龄升序排序SELECT * FROM employee ORDER BY age ASC;SELECT * FROM employee ORDER BY age;-- 两字段排序,根据年龄升序排序,入职时间降序排序SELECT * FROM employee ORDER BY age ASC, entrydata DESC;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="注意事项-3"><a href="#注意事项-3" class="headerlink" title="注意事项"></a>注意事项</h5><p>如果是多字段排序，当第一个字段值相同时，才会根据第二个字段进行排序</p><h4 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h4><p>语法:</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SELECT 字段列表 FROM 表名 LIMIT 起始索引,查询记录数;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>例子:</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">-- 查询第一页数据，展示10条SELECT * FROM employee LIMIT 0, 10;-- 查询第二页SELECT * FROM employee LIMIT 10, 10;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h5 id="注意事项-4"><a href="#注意事项-4" class="headerlink" title="注意事项"></a>注意事项</h5><ul><li>起始索引从0开始,起始索引 = (查询页码-1)*每页显示记录数</li><li>分页查询是数据库的方言，不同的的数据库有不同的实现</li><li>如果查询的是第一页的数据,起始索引可以省略,直接简写LIMIT 10</li></ul><h3 id="DQL执行顺序"><a href="#DQL执行顺序" class="headerlink" title="DQL执行顺序"></a>DQL执行顺序</h3><p>FROM-&gt;WHERE-&gt;GROUP BY-&gt;SELECT-&gt;ORDER BY -&gt;LIMIT</p><h3 id="DCL"><a href="#DCL" class="headerlink" title="DCL"></a>DCL</h3><h4 id="管理用户"><a href="#管理用户" class="headerlink" title="管理用户"></a>管理用户</h4><p>查询用户</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">USER mysql;SELECT * FROM user;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>创建用户:</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">CREATE USER &#39;用户名&#39;@&#39;主机名&#39; IDENTIFIED BY &#39;密码&#39;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>修改用户密码:</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">ALTER USER &#39;用户名&#39;@&#39;主机名&#39; IDENTIFIED WITH mysql_native_password BY &#39;新密码&#39;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>删除用户:</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">DROP USER &#39;用户名&#39;@&#39;主机名&#39;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>例子:</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">-- 创建用户test，只能在当前主机localhost访问create user &#39;test&#39;@&#39;localhost&#39; identified by &#39;123456&#39;;-- 创建用户test，能在任意主机访问create user &#39;test&#39;@&#39;%&#39; identified by &#39;123456&#39;;create user &#39;test&#39; identified by &#39;123456&#39;;-- 修改密码alter user &#39;test&#39;@&#39;localhost&#39; identified with mysql_native_password by &#39;1234&#39;;-- 删除用户drop user &#39;test&#39;@&#39;localhost&#39;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="注意事项-5"><a href="#注意事项-5" class="headerlink" title="注意事项"></a>注意事项</h5><ul><li>主机名可以用%通配</li></ul><h4 id="权限控制"><a href="#权限控制" class="headerlink" title="权限控制"></a>权限控制</h4><p>常用权限:</p><table><thead><tr><th>权限</th><th>说明</th></tr></thead><tbody><tr><td>ALL, ALL PRIVILEGES</td><td>所有权限</td></tr><tr><td>SELECT</td><td>查询数据</td></tr><tr><td>INSERT</td><td>插入数据</td></tr><tr><td>UPDATE</td><td>修改数据</td></tr><tr><td>DELETE</td><td>删除数据</td></tr><tr><td>ALTER</td><td>修改表</td></tr><tr><td>DROP</td><td>删除数据库/表/视图</td></tr><tr><td>CREATE</td><td>创建数据库/表</td></tr></tbody></table><p>查询权限:</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SHOW GRANTS FOR &#39;用户名&#39;@&#39;主机名&#39;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>授予权限:</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">GRANT 权限列表 ON 数据库名.表名 TO &#39;用户名&#39;@&#39;主机名&#39;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>撤销权限:</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">REVOKE 权限列表 ON 数据库名.表名 FROM &#39;用户名&#39;@&#39;主机名&#39;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="注意事项-6"><a href="#注意事项-6" class="headerlink" title="注意事项:"></a>注意事项:</h5><ul><li>多个权限之间用逗号分隔</li><li>授权时,数据库名和表名可以用*进行通配,代表所有</li></ul><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><ul><li>字符串函数</li><li>数值函数</li><li>日期函数</li><li>流程函数</li></ul><h4 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h4><p>常用函数:</p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>CONCAT(s1, s2, …, )</td><td>字符串拼接，将s1, s2, …, 拼接成一个字符串</td></tr><tr><td>LOWER(str)</td><td>将字符串全部转为小写</td></tr><tr><td>UPPER(str)</td><td>将字符串全部转为大写</td></tr><tr><td>LPAD(str, n, pad)</td><td>左填充，用字符串pad对str的左边进行填充，达到n个字符串长度</td></tr><tr><td>RPAD(str, n, pad)</td><td>右填充，用字符串pad对str的右边进行填充，达到n个字符串长度</td></tr><tr><td>TRIM(str)</td><td>去掉字符串头部和尾部的空格</td></tr><tr><td>SUBSTRING(str, start, length)</td><td>返回从字符串str从start位置起的length个长度的字符串</td></tr></tbody></table><p>例子:</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">-- 拼接SELECT CONCAT(&#39;Hello&#39;, &#39;World&#39;);-- 小写SELECT LOWER(&#39;Hello&#39;);-- 大写SELECT UPPER(&#39;Hello&#39;);-- 左填充SELECT LPAD(&#39;01&#39;, 5, &#39;-&#39;);-- 右填充SELECT RPAD(&#39;01&#39;, 5, &#39;-&#39;);-- 去除空格SELECT TRIM(&#39; Hello World &#39;);-- 切片（起始索引为1）SELECT SUBSTRING(&#39;Hello World&#39;, 1, 5);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="数值函数"><a href="#数值函数" class="headerlink" title="数值函数"></a>数值函数</h4><p>常见函数:</p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>CEIL(x)</td><td>向上取整</td></tr><tr><td>FLOOR(x)</td><td>向下取整</td></tr><tr><td>MOD(x, y)</td><td>返回x/y的模</td></tr><tr><td>RAND()</td><td>返回0~1内的随机数</td></tr><tr><td>ROUND(x, y)</td><td>求参数x的四舍五入值，保留y位小数</td></tr></tbody></table><h4 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h4><p>常用函数:</p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>CURDATE()</td><td>返回当前日期</td></tr><tr><td>CURTIME()</td><td>返回当前时间</td></tr><tr><td>NOW()</td><td>返回当前日期和时间</td></tr><tr><td>YEAR(date)</td><td>获取指定date的年份</td></tr><tr><td>MONTH(date)</td><td>获取指定date的月份</td></tr><tr><td>DAY(date)</td><td>获取指定date的日期</td></tr><tr><td>DATE_ADD(date, INTERVAL expr type)</td><td>返回一个日期/时间值加上一个时间间隔expr后的时间值</td></tr><tr><td>DATEDIFF(date1, date2)</td><td>返回起始时间date1和结束时间date2之间的天数</td></tr></tbody></table><p>例子</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">-- DATE_ADDSELECT DATE_ADD(NOW(), INTERVAL 70 YEAR);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>流程函数:</p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>IF(value,t,f)</td><td>如果value为true，则返回t，否则返回f</td></tr><tr><td>IFNULL(value1, value2)</td><td>如果value1不为空，返回value1，否则返回value2</td></tr><tr><td>CASE WHEN [ val1 ] THEN [ res1 ] … ELSE [ default ] END</td><td>如果val1为true，返回res1，… 否则返回default默认值</td></tr><tr><td>CASE [ expr ] WHEN [ val1 ] THEN [ res1 ] … ELSE [ default ] END</td><td>如果expr的值等于val1，返回res1，… 否则返回default默认值</td></tr></tbody></table><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">select    name,    (case when age &gt; 30 then &#39;中年&#39; else &#39;青年&#39; end)from employee;select    name,    (case workaddress when &#39;北京市&#39; then &#39;一线城市&#39; when &#39;上海市&#39; then &#39;一线城市&#39; else &#39;二线城市&#39; end) as &#39;工作地址&#39;from employee;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h3><p>分类:</p><table><thead><tr><th>约束</th><th>描述</th><th>关键字</th></tr></thead><tbody><tr><td>非空约束</td><td>限制该字段的数据不能为null</td><td>NOT NULL</td></tr><tr><td>唯一约束</td><td>保证该字段的所有数据都是唯一、不重复的</td><td>UNIQUE</td></tr><tr><td>主键约束</td><td>主键是一行数据的唯一标识,要求非空且唯一</td><td>PRIMARY KEY</td></tr><tr><td>默认约束</td><td>保存数据时，如果未指定该字段的值，则采用默认值</td><td>DEFAULT</td></tr><tr><td>检查约束(8.0.1版本后)</td><td>保证字符值满足某一个条件</td><td>CHECK</td></tr><tr><td>外键约束</td><td>用来让两张图的数据之间完整建立连接,保证数据的一致性和完整性</td><td>FOREIGN KEY</td></tr></tbody></table><p>约束是作用于表中字段上的，可以在创建/修改表的时候添加约束。</p><h4 id="常用的约束"><a href="#常用的约束" class="headerlink" title="常用的约束"></a>常用的约束</h4><table><thead><tr><th>约束条件</th><th>关键字</th></tr></thead><tbody><tr><td>主键</td><td>PRIMARY KEY</td></tr><tr><td>自动增长</td><td>AUTO_INCREMENT</td></tr><tr><td>不为空</td><td>NOT NULL</td></tr><tr><td>唯一</td><td>UNIQUE</td></tr><tr><td>逻辑条件</td><td>CHECK</td></tr><tr><td>默认值</td><td>DEFAULT</td></tr></tbody></table><p>例子:</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">create table user(    id int primary key auto_increment,    name varchar(10) not null unique,    age int check(age &gt; 0 and age &lt; 120),    status char(1) default &#39;1&#39;,    gender char(1));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h4><p>添加外键:</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">CREATE TABLE 表名(    字段名 字段类型,    ...    [CONSTRAINT] [外键名称] FOREIGN KEY(外键字段名) REFERENCES 主表(主表列名));ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名) REFERENCES 主表(主表列名);-- 例子alter table emp add constraint fk_emp_dept_id foreign key(dept_id) references dept(id);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>删除外键:</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">ALTER TABLE 表名 DROP FOREIGN KEY 外键名;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="删除-更新行为"><a href="#删除-更新行为" class="headerlink" title="删除/更新行为"></a>删除/更新行为</h4><table><thead><tr><th>行为</th><th>说明</th></tr></thead><tbody><tr><td>NO ACTION</td><td>当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除/更新（与RESTRICT一致）</td></tr><tr><td>RESTRICT</td><td>当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除/更新（与NO ACTION一致）</td></tr><tr><td>CASCADE</td><td>当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则也删除/更新外键在子表中的记录</td></tr><tr><td>SET NULL</td><td>当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则设置子表中该外键值为null（要求该外键允许为null）</td></tr><tr><td>SET DEFAULT</td><td>父表有变更时，子表将外键设为一个默认值（Innodb不支持</td></tr></tbody></table><p>更改删除/更新行为:</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段) REFERENCES 主表名(主表字段名) ON UPDATE 行为 ON DELETE 行为;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KMP算法思路归纳</title>
      <link href="/2021/09/13/KMP%E7%AE%97%E6%B3%95/"/>
      <url>/2021/09/13/KMP%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>今天学习了判断字符串匹配操作中的kmp算法，现对此进行一个简单的梳理和归纳，思路主要来源于知乎上对kmp算法的几篇详细分析文章：<a href="https://www.zhihu.com/question/21923021">https://www.zhihu.com/question/21923021</a> 另外B站上也有kmp算法的视频演示教学： <a href="https://www.bilibili.com/video/BV1jb411V78H?from=search&amp;seid=13467499309274367749&amp;spm_id_from=333.337.0.0">https://www.bilibili.com/video/BV1jb411V78H?from=search&amp;seid=13467499309274367749&amp;spm_id_from=333.337.0.0</a></p><h2 id="字符串的匹配问题"><a href="#字符串的匹配问题" class="headerlink" title="字符串的匹配问题"></a>字符串的匹配问题</h2><p>字符串的匹配是对字符串的常见操作，具体来说就是：给定字符串A和B，让我们来判断B是否为A的字串，如果是，B出现在A串的什么位置？其中，A称作<strong>主串</strong>，B称作<strong>模式串</strong>。<br>c++</p><p><img src="https://pic.imgdb.cn/item/613f760644eaada739c7ca14.png"></p><h2 id="BF算法-Brute-Force"><a href="#BF算法-Brute-Force" class="headerlink" title="BF算法(Brute-Force)"></a>BF算法(Brute-Force)</h2><p>在谈及Kmp算法之前，我们需要先了解一下BF算法，这样才能让KMP的算法优势更为明显。Brute—Force，顾名思义，这是一种暴力的解法。其思路也很简单：给定主串A和模式串B，将A和B的每个字符逐个比较，如果一致则继续比较下一个字符，当匹配到不一致时就将模式串后移一位，然后重新从模式串的首位开始对比，重复先前步骤。</p><p><img src="https://pic.imgdb.cn/item/613f760644eaada739c7ca4d.png"></p><p><img src="https://pic.imgdb.cn/item/613f760644eaada739c7cbc0.png"></p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>例子：给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 -1。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">strStr</span><span class="token punctuation">(</span><span class="token class-name">String</span> haystack<span class="token punctuation">,</span> <span class="token class-name">String</span> needle<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> haylen <span class="token operator">=</span> haystack<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> needlen <span class="token operator">=</span> needle<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">//特殊情况</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>haylen <span class="token operator">&lt;</span> needlen<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>needlen <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">//主串</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> haylen <span class="token operator">-</span> needlen <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> j<span class="token punctuation">;</span>            <span class="token comment">//模式串</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> needlen<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">//不符合的情况，直接跳出，主串指针后移一位</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>haystack<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token operator">+</span>j<span class="token punctuation">)</span> <span class="token operator">!=</span> needle<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">//匹配成功</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">==</span> needlen<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">return</span> i<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>         <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="BF算法时间复杂度讨论及改进思路"><a href="#BF算法时间复杂度讨论及改进思路" class="headerlink" title="BF算法时间复杂度讨论及改进思路"></a>BF算法时间复杂度讨论及改进思路</h3><p>设主串长度为n，模式串长度为m，在BF算法中，完成一趟匹配至少要进行一次比较，最多要进行m次比较。BF算法最多进行n-m+1趟匹配，因此最坏情况下一共要进行m(n-m+1)次比较，考虑到主串的长度应远大于模式穿，所以时间复杂度为O(m*n)。最坏情况是每一趟匹配都在最后一个字符失配，如a=”cccccc”, b=”ccb”。</p><p>改进思路：BF算法的缺点很明显，那就是进行了太多没必要的比较。因此，我们考虑<strong>降低比较的趟数</strong>，有些趟字符串比较是有可能会成功的；有些则毫无可能。如果我们跳过那些绝不可能成功的字符串比较，就可以减少不必要的比较趟数来降低算法的复杂度。</p><h2 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h2><h3 id="前缀和后缀"><a href="#前缀和后缀" class="headerlink" title="前缀和后缀"></a>前缀和后缀</h3><p>在使用KMP算法之前，我们需要了解几个概念：前缀、后缀、相同前后缀的最大长。</p><p>abcdef的前缀：a、ab、abc、abcd、abcde（注意：abcdef不是前缀）<br>abcdef的后缀：f、ef、def、cdef、bcdef（注意：abcdef不是后缀）<br>abcdef的公共最大长：0（因为其前缀与后缀没有相同的）<br>ababa的前缀：a、ab、aba、abab<br>ababa的后缀：a、ba、aba、baba<br>ababa的相同前后缀的最大长：3（因为他们的公共前缀后缀中最长的为aba，长度3）</p><h3 id="利用用相同前后缀的最大长度设计KMP算法"><a href="#利用用相同前后缀的最大长度设计KMP算法" class="headerlink" title="利用用相同前后缀的最大长度设计KMP算法"></a>利用用相同前后缀的最大长度设计KMP算法</h3><p>如下图所示，模式串在与主串配对中，当i指向a，j指向c时失配，那么主串和模式串的前6位是相同的。又因为模式串的前6位，它的它的前4位前缀和后4位后缀是相同的，因此主串i之前的4位和模式串的开头4位是相同的。因此我们只需要将j移动到最大相同前后缀中，<strong>前缀的末尾字符的后一位</strong>，再次和i指向的字符进行逐个比对即可。因此，问题转变成了如何来求解j指向字符之前的子串的最长公共前后缀的长度呢？因为有了这个长度，我们才能知道到底要移动多少位置。因此，我们就要去了解kmp算法的核心——next数组的求解。<br><img src="https://pic2.zhimg.com/80/v2-03a0d005badd0b8e7116d8d07947681c_720w.jpg?source=1940ef5c"></p><h3 id="next数组"><a href="#next数组" class="headerlink" title="next数组"></a>next数组</h3><p>KMP中有一个数组，这个数组叫做next数组，它存放的是最长公共前后缀中，前缀的结尾字符下标。如下图示：  </p><p><img src="https://pic.imgdb.cn/item/613f760644eaada739c7cc28.png"><br>学会使用了next数组后，我们就可以利用它完成KMP算法。  </p><p><img src="https://pica.zhimg.com/80/v2-1103f9e0dde26da60c503e8f1f7bb01e_720w.jpg?source=1940ef5c"></p><p><img src="https://pic3.zhimg.com/80/v2-cee0b1ab9afd304229d3b271475240b4_720w.jpg?source=1940ef5c"></p><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><p>下面给出KMP算法的Java语言实现：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">KmpTest</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span>  <span class="token keyword">int</span> <span class="token function">strStr</span><span class="token punctuation">(</span><span class="token class-name">String</span> haystack<span class="token punctuation">,</span> <span class="token class-name">String</span> needle<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//haystack为主串 needle为模式串</span>        <span class="token comment">//两种特殊情况</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>needle<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>haystack<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment">// char 数组</span>        <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> hasyarr <span class="token operator">=</span> haystack<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nearr <span class="token operator">=</span> needle<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//长度</span>        <span class="token keyword">int</span> halen <span class="token operator">=</span> hasyarr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">int</span> nelen <span class="token operator">=</span> nearr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token comment">//返回下标</span>        <span class="token keyword">return</span> <span class="token function">kmp</span><span class="token punctuation">(</span>hasyarr<span class="token punctuation">,</span> halen<span class="token punctuation">,</span> nearr<span class="token punctuation">,</span> nelen<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">kmp</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> hasyarr<span class="token punctuation">,</span> <span class="token keyword">int</span> halen<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nearr<span class="token punctuation">,</span> <span class="token keyword">int</span> nelen<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//获取next数组</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> next <span class="token operator">=</span> <span class="token function">next</span><span class="token punctuation">(</span>nearr<span class="token punctuation">,</span> nelen<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> halen<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">/*发现不匹配的字符，然后根据next数组移动指针，移动到最大公共前后缀的            前缀的后一位*/</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> hasyarr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> nearr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                j <span class="token operator">=</span> next<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token comment">//如果已经超出长度，直接返回不存在</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>nelen <span class="token operator">-</span> j <span class="token operator">+</span> i <span class="token operator">></span> halen<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">//如果相同就将指针同时向后移动，比较下个字符。</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>hasyarr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> nearr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token operator">++</span>j<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">//遍历完整个模式串，返回模式串的起点下标</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">==</span> nelen<span class="token punctuation">)</span>                <span class="token keyword">return</span> i <span class="token operator">-</span> nelen <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">//若遍历完全部都没有匹配 那就从这里返回-1 匹配失败</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> needle<span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//定义next数组</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>len<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">//初始化</span>        next<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">/*初始化k+1为串首字符的下标，needle[i]始终为子串的串尾        下标。先通过k比较首字符，当首字符比较完毕后来判断剩余字符*/</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span>len <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>k <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&amp;&amp;</span> needle<span class="token punctuation">[</span>k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">!=</span> needle<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                k <span class="token operator">=</span> next<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>needle<span class="token punctuation">[</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">==</span>needle<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>                k<span class="token operator">++</span><span class="token punctuation">;</span>            next<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>k<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单链表的冒泡排序</title>
      <link href="/2021/09/12/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
      <url>/2021/09/12/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>冒泡排序是最基本也是最简单的一种排序，时间复杂度为O(n^2)，我们可以使用它来对单链表进行排序操作。</p><h2 id="链表定义"><a href="#链表定义" class="headerlink" title="链表定义"></a>链表定义</h2><p>本次链表采用以下的结构定义：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">node</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> element<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">node</span> <span class="token operator">*</span>link<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>Node<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">headerList</span><span class="token punctuation">&#123;</span>Node <span class="token operator">*</span>head<span class="token punctuation">;</span><span class="token keyword">int</span> n<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>HeaderList<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="算法一"><a href="#算法一" class="headerlink" title="算法一"></a>算法一</h2><p>冒泡排序算法的原始思想：<br>比较相邻的元素。如果第一个比第二个大，就交换他们两个。对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。针对所有的元素重复以上的步骤，除了最后一个。</p><h3 id="数组代码实现"><a href="#数组代码实现" class="headerlink" title="数组代码实现"></a>数组代码实现</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> length<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> temp<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">-</span> j<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> a<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                temp <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                a<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>将上述思想套用到链表中，我们知道在冒泡排序中要交换数据，所以链表中需要通过指针指向的改变来达到交换的目的，而不是简单节点数据交换。两个节点要想交换位置，必须用2个以上的指针来表明指示要交换节点的前驱和本身，必要时用到后继指针。</p><h3 id="链表冒泡排序"><a href="#链表冒泡排序" class="headerlink" title="链表冒泡排序"></a>链表冒泡排序</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span>HeaderList <span class="token operator">&amp;</span>L<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>L<span class="token punctuation">.</span>head<span class="token operator">-></span>link<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"该链表无节点！"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    Node<span class="token operator">*</span> tail <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>   <span class="token comment">//（tail指向上一轮找出最大值的位置）</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>tail <span class="token operator">!=</span> L<span class="token punctuation">.</span>head<span class="token operator">-></span>link<span class="token operator">-></span>link<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">//最大值已到链表第二位置</span>        Node<span class="token operator">*</span> p <span class="token operator">=</span> L<span class="token punctuation">.</span>head<span class="token punctuation">;</span>  <span class="token comment">//外循环开始，先指向头节点</span>        Node<span class="token operator">*</span> q <span class="token operator">=</span> p<span class="token operator">-></span>link<span class="token punctuation">;</span>          <span class="token keyword">while</span> <span class="token punctuation">(</span>q<span class="token operator">-></span>link <span class="token operator">!=</span> tail<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token comment">//下个节点是上一轮最大值的位置</span><span class="token keyword">if</span> <span class="token punctuation">(</span>q<span class="token operator">-></span>element <span class="token operator">></span> q<span class="token operator">-></span>link<span class="token operator">-></span>element<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                 p<span class="token operator">-></span>link <span class="token operator">=</span> q<span class="token operator">-></span>link<span class="token punctuation">;</span> <span class="token comment">//让当前节点的先驱指向相邻的节点</span>                Node<span class="token operator">*</span> temp <span class="token operator">=</span> q<span class="token operator">-></span>link<span class="token operator">-></span>link<span class="token punctuation">;</span> <span class="token comment">//保存相邻节点的后继</span>                p<span class="token operator">-></span>link<span class="token operator">-></span>link <span class="token operator">=</span> q<span class="token punctuation">;</span>     <span class="token comment">//令相邻节点的后继等于当前节点</span>                q<span class="token operator">-></span>link <span class="token operator">=</span> temp<span class="token punctuation">;</span>  <span class="token comment">//当前节点指向先前保存的后继</span>                p <span class="token operator">=</span> p<span class="token operator">-></span>link<span class="token punctuation">;</span>   <span class="token comment">//因为mid交换以后，已经后移了一步，所以这里只需前驱后移</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>         <span class="token comment">//未交换，手动后移这两个指针</span>                p <span class="token operator">=</span> q<span class="token punctuation">;</span>                q <span class="token operator">=</span> q<span class="token operator">-></span>link<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        tail <span class="token operator">=</span> q<span class="token punctuation">;</span>   <span class="token comment">//tail指向这一轮找出最大值的位置。</span>    <span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="算法二"><a href="#算法二" class="headerlink" title="算法二"></a>算法二</h2><p> 另一种冒泡排序的思想，从所有的第一个开始，以第一个为基准，与剩余所有的数比较，选出最小的放在第一位，之后以第二个位置为基准，与剩余所有的数比较，选出最小的放在第二位，直到全部遍历完。</p><h3 id="数组代码实现-1"><a href="#数组代码实现-1" class="headerlink" title="数组代码实现"></a>数组代码实现</h3> <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   <span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> temp<span class="token punctuation">;</span>   <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>       <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n <span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>           <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>               temp <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>               a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>               a<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>           <span class="token punctuation">&#125;</span>       <span class="token punctuation">&#125;</span>   <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="链表冒泡排序-1"><a href="#链表冒泡排序-1" class="headerlink" title="链表冒泡排序"></a>链表冒泡排序</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span>HeaderList <span class="token operator">&amp;</span>L<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>L<span class="token punctuation">.</span>head<span class="token operator">-></span>link<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"该链表无节点！"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>Node<span class="token operator">*</span> pre <span class="token operator">=</span> L<span class="token punctuation">.</span>head<span class="token punctuation">;</span>        Node<span class="token operator">*</span> mid <span class="token operator">=</span> pre<span class="token operator">-></span>link<span class="token punctuation">,</span> <span class="token operator">*</span>after<span class="token punctuation">,</span><span class="token operator">*</span>afterPre<span class="token punctuation">,</span><span class="token operator">*</span>temp<span class="token punctuation">;</span><span class="token comment">//指向第一个节点，声明内循环中要用的指针</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>mid<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                  after <span class="token operator">=</span> mid<span class="token operator">-></span>link<span class="token punctuation">;</span>  <span class="token comment">//冒泡第二种形式的思想，让外循环的一个节点与剩余的所有节点比较</span>        afterPre <span class="token operator">=</span> mid<span class="token punctuation">;</span>     <span class="token comment">//该节点的前驱指针，方便我们进行交换</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>after<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>     <span class="token comment">//</span><span class="token keyword">if</span> <span class="token punctuation">(</span>mid<span class="token operator">-></span>element <span class="token operator">></span> after<span class="token operator">-></span>element<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                 afterPre<span class="token operator">-></span>link <span class="token operator">=</span> mid<span class="token punctuation">;</span>                       pre<span class="token operator">-></span>link <span class="token operator">=</span> after<span class="token punctuation">;</span>         <span class="token comment">//首先让这两个节点的前驱变了</span>                temp <span class="token operator">=</span> mid<span class="token operator">-></span>link<span class="token punctuation">;</span>         <span class="token comment">//保留外循环中要比较的节点的后继，方便交换过来的节点正确的接上</span>                mid<span class="token operator">-></span>link <span class="token operator">=</span> after<span class="token operator">-></span>link<span class="token punctuation">;</span>  <span class="token comment">//接上交换过来的后继位置</span>                after<span class="token operator">-></span>link <span class="token operator">=</span> temp<span class="token punctuation">;</span>      <span class="token comment">//接上交换过来的后继位置</span>                temp <span class="token operator">=</span> mid<span class="token punctuation">;</span>       <span class="token comment">//mid 和 after 所指向的节点在 链表中已交换位置，所以mid和after指针的地址交换</span>                mid <span class="token operator">=</span> after<span class="token punctuation">;</span>     <span class="token comment">//</span>                after <span class="token operator">=</span> mid<span class="token punctuation">;</span>    <span class="token comment">//将mid和after的指针的值交换，才能继续以mid所指向的节点当作外循环的基准节点</span>                               <span class="token comment">//after才能正确作为内循环要移动并比较的节点指针。</span>            <span class="token punctuation">&#125;</span>            afterPre <span class="token operator">=</span> after<span class="token punctuation">;</span>               after <span class="token operator">=</span> after<span class="token operator">-></span>link<span class="token punctuation">;</span>  <span class="token comment">//后移前驱和本身</span>        <span class="token punctuation">&#125;</span>        pre <span class="token operator">=</span> mid<span class="token punctuation">;</span>         mid <span class="token operator">=</span> mid<span class="token operator">-></span>link<span class="token punctuation">;</span>  <span class="token comment">//外循环需要后移一步，继续下一轮内循环遍历</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2021/09/12/hello-world/"/>
      <url>/2021/09/12/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-none"><code class="language-none">$ hexo new &quot;My New Post&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-none"><code class="language-none">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-none"><code class="language-none">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
